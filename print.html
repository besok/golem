<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation for Forester</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">2.</strong> Components</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">3.</strong> Setup</a></li><li class="chapter-item expanded "><a href="intro_lang.html"><strong aria-hidden="true">4.</strong> Tree language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">4.1.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="imports.html"><strong aria-hidden="true">4.2.</strong> Imports</a></li><li class="chapter-item expanded "><a href="definitions.html"><strong aria-hidden="true">4.3.</strong> Definitions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow.html"><strong aria-hidden="true">4.3.1.</strong> Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="seq.html"><strong aria-hidden="true">4.3.1.1.</strong> Sequences</a></li><li class="chapter-item expanded "><a href="falls.html"><strong aria-hidden="true">4.3.1.2.</strong> Fallbacks</a></li><li class="chapter-item expanded "><a href="par.html"><strong aria-hidden="true">4.3.1.3.</strong> Parallel</a></li></ol></li><li class="chapter-item expanded "><a href="decorators.html"><strong aria-hidden="true">4.3.2.</strong> Decorators</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">4.3.3.</strong> Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="builtin.html"><strong aria-hidden="true">4.3.3.1.</strong> Built-In</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="invoc_intro.html"><strong aria-hidden="true">4.4.</strong> Invocations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hot.html"><strong aria-hidden="true">4.4.1.</strong> Higher order tree</a></li><li class="chapter-item expanded "><a href="lambda.html"><strong aria-hidden="true">4.4.2.</strong> Lambda</a></li></ol></li><li class="chapter-item expanded "><a href="params.html"><strong aria-hidden="true">4.5.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="antlr.html"><strong aria-hidden="true">4.6.</strong> Antlr grammar</a></li></ol></li><li class="chapter-item expanded "><a href="engine_intro.html"><strong aria-hidden="true">5.</strong> Runtime engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine.html"><strong aria-hidden="true">5.1.</strong> Engine</a></li><li class="chapter-item expanded "><a href="rt_args.html"><strong aria-hidden="true">5.2.</strong> Runtime arguments</a></li><li class="chapter-item expanded "><a href="bb.html"><strong aria-hidden="true">5.3.</strong> Blackboard</a></li><li class="chapter-item expanded "><a href="r_actions.html"><strong aria-hidden="true">5.4.</strong> Actions</a></li><li class="chapter-item expanded "><a href="trimming.html"><strong aria-hidden="true">5.5.</strong> Trimming</a></li><li class="chapter-item expanded "><a href="daemons.html"><strong aria-hidden="true">5.6.</strong> Daemons</a></li></ol></li><li class="chapter-item expanded "><a href="analysis.html"><strong aria-hidden="true">6.</strong> Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="viz.html"><strong aria-hidden="true">6.1.</strong> Visualization</a></li><li class="chapter-item expanded "><a href="trace.html"><strong aria-hidden="true">6.2.</strong> Tracing</a></li><li class="chapter-item expanded "><a href="sim.html"><strong aria-hidden="true">6.3.</strong> Simulation</a></li><li class="chapter-item expanded "><a href="ros_nav2.html"><strong aria-hidden="true">6.4.</strong> Export to ROS Nav2</a></li></ol></li><li class="chapter-item expanded "><a href="f_examples.html"><strong aria-hidden="true">7.</strong> Examples</a></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">8.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intellij.html"><strong aria-hidden="true">8.1.</strong> Intellij plugin</a></li><li class="chapter-item expanded "><a href="rem_action.html"><strong aria-hidden="true">8.2.</strong> Remote Action</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rem_action_rs.html"><strong aria-hidden="true">8.2.1.</strong> Rust library for Remote Action</a></li><li class="chapter-item expanded "><a href="rem_action_py.html"><strong aria-hidden="true">8.2.2.</strong> Python library for Remote Action</a></li></ol></li><li class="chapter-item expanded "><a href="console.html"><strong aria-hidden="true">8.3.</strong> Console</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Documentation for Forester</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="pics%2Flogo.png" alt="logo.png" /></p>
<h1 id="forester"><a class="header" href="#forester">Forester</a></h1>
<p>Forester represents a framework that provides the set of tools to perform the effective orchestration of the set of tasks.<br />
The tasks can be performed synchronously or asynchronously, locally or remotely.<br />
Forester takes care of the correct performance and distribution of the tasks.<br />
the main concept of the framework
is the flow based on the <a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)#:~:text=A%20behavior%20tree%20is%20a,tasks%20in%20a%20modular%20fashion.">behavior trees</a><br />
it can be effectively used in the game, ai, robotic areas, or anywhere where the workflow engine can be applied.</p>
<h2 id="why-forester"><a class="header" href="#why-forester">Why Forester</a></h2>
<p>The main idea and the target of Forester is to make the process of chaining a complex logic <br />
of the different tasks together effective and easy.</p>
<p>The following set of features is summoned to highlight the framework among the others.</p>
<h4 id="the-dsl-to-describe-the-logic"><a class="header" href="#the-dsl-to-describe-the-logic">The dsl to describe the logic</a></h4>
<p>One of the problems that Forester endeavours to solve is to isolate the logic of the orchestration \
from the logic of the tasks implementations and therefore the dsl ('Tree') is provided. <br />
The Dsl is script based and supports a number of features that can alleviate the writing of the big trees.</p>
<h4 id="the-framework-provides-the-ability-to-create-async-and-sync-tasks"><a class="header" href="#the-framework-provides-the-ability-to-create-async-and-sync-tasks">The framework provides the ability to create async and sync tasks</a></h4>
<p>The tasks (leaves of the tree) can be fulfilled with the asynchronous and synchronous logic.
The difference here is the async tasks will not block the tree while sync tasks will block the tree.</p>
<h4 id="the-framework-provides-the-ability-to-create-remote-and-local-tasks-tbd"><a class="header" href="#the-framework-provides-the-ability-to-create-remote-and-local-tasks-tbd">The framework provides the ability to create remote and local tasks (TBD)</a></h4>
<p>The tasks can represent as a local stateless/stateful blocks of logic as the remote servers or procedures.</p>
<h4 id="the-tooling-to-visualize-and-trace-the-execution-of-the-tree"><a class="header" href="#the-tooling-to-visualize-and-trace-the-execution-of-the-tree">The tooling to visualize and trace the execution of the tree</a></h4>
<p>The tree can be visualized and traced in order to see how it is supposed to be executed.</p>
<h4 id="the-simulation-mode-is-supposed-to-aid-with-the-design-decisions"><a class="header" href="#the-simulation-mode-is-supposed-to-aid-with-the-design-decisions">The simulation mode is supposed to aid with the design decisions</a></h4>
<p>The special simulation mode aims to help, quickly to see how the tree will be unfolding and how it can be designed.</p>
<h4 id="the-optimizations-and-analysis-of-the-tree-tbd"><a class="header" href="#the-optimizations-and-analysis-of-the-tree-tbd">The optimizations and analysis of the tree (TBD)</a></h4>
<p>The language provides a set of optimizations and validations to either ensure the logic is correct <br />
or perform some validations on it.</p>
<h4 id="the-validations-engine-allows-the-users-to-create-the-manually-defined-validations-tbd"><a class="header" href="#the-validations-engine-allows-the-users-to-create-the-manually-defined-validations-tbd">The validations engine allows the users to create the manually defined validations (TBD)</a></h4>
<p>The user-defined validations can be useful to restrict some features of the framework.</p>
<h4 id="integrations-tbd"><a class="header" href="#integrations-tbd">Integrations (TBD)</a></h4>
<h2 id="why-behavior-trees"><a class="header" href="#why-behavior-trees">Why behavior trees</a></h2>
<p>Firstly, they provide a strong math abstraction over the orchestration logic <br />
and enables to separate the business logic and the tree logic itself.
One of the great advantages of the behavior trees is that they provide a good conception of modularity. <br />
On the other hand, they have only a small set of logically conjucted components making the design easier,</p>
<h3 id="articles-that-introduce-into-the-basics-of-the-behaviour-trees"><a class="header" href="#articles-that-introduce-into-the-basics-of-the-behaviour-trees">Articles that introduce into the basics of the behaviour trees</a></h3>
<ul>
<li><a href="https://outforafight.wordpress.com/2014/07/15/behaviour-behavior-trees-for-ai-dudes-part-1/">Chris Simpson’s Behavior trees for AI: How they work</a></li>
<li><a href="https://robohub.org/introduction-to-behavior-trees/">Introduction to behavior trees</a></li>
<li><a href="https://www.polymathrobotics.com/blog/state-machines-vs-behavior-trees">State Machines vs Behavior Trees</a></li>
</ul>
<h3 id="useful-libraries"><a class="header" href="#useful-libraries">Useful libraries</a></h3>
<ul>
<li><a href="https://www.behaviortree.dev/">BehaviorTree.CPP</a> : the brilliant library provides the implementation on CPP.</li>
<li><a href="https://github.com/bitbrain/beehave">Beehave</a> :  behavior tree AI for Godot Engine.</li>
<li><a href="https://github.com/Sollimann/bonsai">Bonsai</a> : the great library for behavior trees in rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>All in all, the framework provides the following components :</p>
<ul>
<li>Analysis
<ul>
<li>Visualization</li>
<li>Tracing</li>
<li>Simulatioon</li>
</ul>
</li>
<li>Language as an entry point</li>
<li>Runtime</li>
<li>Console utility and extention</li>
</ul>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>That section describes the language and a way how the users can describe the logic of the trees:</p>
<h3 id="tree-lang"><a class="header" href="#tree-lang">Tree lang</a></h3>
<p>The scripts. They are usually can be stored as a folder with one or more <code>root</code> node which will be executed afterwords.
The syntax of the language takes a vast part of the book and described in the following <a href="./intro_lang.html">chapter</a></p>
<h3 id="validations-and-optimizations"><a class="header" href="#validations-and-optimizations">Validations and Optimizations</a></h3>
<p>These parts come with static analyzer and are conducted when the users compile the scripts into the runtime tree.
They are described in the corresponding sections <a href="./validations.html">Validations</a> and <a href="./optimizations.html">Optimizations</a></p>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<p>There are some number of extensions for ides to alleviate the writing scripts and running the trees.
The detailed description is in the chapter <a href="./tools.html">Tools</a></p>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>That is the central part of the framework. The runtime orchestrates the tree execution alongside <br />
with the storing and manipulating some data and actions.</p>
<h3 id="engine"><a class="header" href="#engine">Engine</a></h3>
<p>The main orchestrator. It is described in the chapter <a href="./engine.html">Engine</a></p>
<h3 id="blackboard"><a class="header" href="#blackboard">Blackboard</a></h3>
<p>The component which is responsible for the storing the intermediate data that can be passing across the tree.
The mechanism of working is described in that <a href="./bb.html">chapter</a></p>
<h3 id="actionkeeper"><a class="header" href="#actionkeeper">ActionKeeper</a></h3>
<p>The component stores and processes the user implemented actions (<em>tasks</em> or <em>conditions</em>).
The chapter <a href="./actions.html">Action</a> describes how to interact with ActionKeeper.</p>
<h2 id="analysis"><a class="header" href="#analysis">Analysis</a></h2>
<p>This component helps to analyse the trees and also interacts with them in an easy way</p>
<h3 id="visualization"><a class="header" href="#visualization">Visualization</a></h3>
<p>The users can visualize the tree using graphviz format.
This <a href="./viz.html">section</a> explains how to do that.</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>The users can turn on some extra logging that can float up some extra meta information \
helpful to design and debug the trees. This <a href="./trace.html">page</a> explains how to handle the tracing.</p>
<h3 id="simulation"><a class="header" href="#simulation">Simulation</a></h3>
<p>The users can run the tree with some stubs instead of the real implementations of the actions. \
It can help swiftly define and correct the behavior of the tree itself.
This <a href="./sim.html">chapter</a> describes it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>There are two ways to interact with Forester</p>
<h2 id="using-console-utility-for-simulation-and-visualization"><a class="header" href="#using-console-utility-for-simulation-and-visualization">Using console utility for simulation and visualization</a></h2>
<p>The console utility <code>f-tree</code> can be installed using <code>cargo</code></p>
<pre><code class="language-shell">cargo install f-tree
</code></pre>
<p>and then be used with</p>
<pre><code class="language-shell">~ f-tree
A console utility to interact with Forester

Usage: f-tree &lt;COMMAND&gt;

Commands:
  sim   Runs simulation. Expects a simulation profile
  vis   Runs visualization. Output is in svg format.
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
</code></pre>
<h2 id="as-a-dependency-to-run-from-a-rust-code"><a class="header" href="#as-a-dependency-to-run-from-a-rust-code">As a dependency to run from a rust code</a></h2>
<pre><code class="language-toml">forester-rs = "*"
</code></pre>
<h3 id="from-file-system"><a class="header" href="#from-file-system">From file system</a></h3>
<pre><pre class="playground"><code class="language-rust">
 use std::path::PathBuf;
 use forester_rs::flow;
 use forester_rs::tracer::Tracer;
 use forester_rs::runtime::builder::ForesterBuilder;
 use forester_rs::runtime::action::Action;
 use forester_rs::runtime::action::builtin::data::StoreData;

fn main() {
    let mut fb = ForesterBuilder::from_file_system();
    fb.main_file("main.tree".to_string());
    fb.root(root);
    fb.register_action("store", Action::sync(StoreData));
    fb.tracer(Tracer::default());
    fb.bb_load("db/db.json".to_string());
    
    let forester = fb.build().unwrap();

    let result = forester.run().unwrap();
    println!("result {:?}",result);
}

</code></pre></pre>
<h3 id="on-the-fly-for-small-scripts"><a class="header" href="#on-the-fly-for-small-scripts">On the fly for small scripts</a></h3>
<pre><pre class="playground"><code class="language-rust">
use std::path::PathBuf;
use forester_rs::flow;
use forester_rs::tracer::Tracer;
use forester_rs::runtime::builder::ForesterBuilder;
use forester_rs::runtime::action::Action;
use forester_rs::runtime::action::builtin::data::StoreData;

fn main() {
    let mut fb = ForesterBuilder::from_text();
    fb.register_action("cv",Action::sync(ReturnResult::success()));
    
    fb.text(r#"
        root main sequence {
            cv()
            cv()
            cv()
        }
    "#.to_string());
    let mut forester = fb.build().unwrap();

    let result = forester.run().unwrap();
    println!("result {:?}",result);
}

</code></pre></pre>
<h3 id="manually-construct-the-trees"><a class="header" href="#manually-construct-the-trees">Manually construct the trees</a></h3>
<pre><pre class="playground"><code class="language-rust">
use std::path::PathBuf;
use forester_rs::flow;
use forester_rs::tracer::Tracer;
use forester_rs::runtime::builder::ForesterBuilder;
use forester_rs::runtime::action::Action;
use forester_rs::runtime::action::builtin::data::StoreData;

fn main() {
    let mut fb = ForesterBuilder::from_code();
    fb.register_action("cv",Action::sync(ReturnResult::success()));
    fb.add_rt_node(
          flow!(fallback node_name!(), args!();
              action!(),
              action!(),
              action!(),
              action!()
          )
    );
    let mut forester = fb.build().unwrap();

    let result = forester.run().unwrap();
    println!("result {:?}",result);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-language"><a class="header" href="#tree-language">Tree language</a></h1>
<p>The tree language is a frontend for the framework itself.
Generally, the language is a simple dsl encompassing the basic abstractions <br />
and enabling to create of the building block upon the abstractions \</p>
<h3 id="why-the-language-is-needed"><a class="header" href="#why-the-language-is-needed">Why the language is needed</a></h3>
<p>The basic idea behind the language is an attempt to provide a set of generalizations <br />
which will alleviate the redundancy in some cases.</p>
<ul>
<li>The language allows creating the tree definitions accepting other trees as parameters (higher order trees)</li>
<li>The language provides lambda definitions</li>
</ul>
<p>The syntax of the language is very simple and is described in this chapter.</p>
<h3 id="structure-of-the-project"><a class="header" href="#structure-of-the-project">Structure of the project</a></h3>
<p>The scripts are supposed to be in the folder which is marked as <code>root</code> directory.
All imports start from the root and represent a path relating to the root directory:</p>
<pre><code class="language-file"> - project_folder
    - main.tree
    - gripper.tree
    - cv.tree
    - utility
        - utility.tree
        - helpers.tree
</code></pre>
<p>The project should have at least one <code>root</code> tree <a href="./definitions.html">definition</a>. If the project has several,
the one that is supposed to run needs to be pointed out to.</p>
<h3 id="file-extension"><a class="header" href="#file-extension">File extension</a></h3>
<p>The files have the extension <code>tree</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>The syntax of the <code>tree</code> language is similar to any average scripting language namely it consists of:</p>
<ul>
<li>tree definitions: subtree that defines a prat of the complete tree.</li>
<li>tree invocations: the calls of the tree definitions.</li>
<li>imports: the instructions that enable import from the other files.</li>
<li>parameters and arguments: that allow passing the values and the other tree to the tree definitions.</li>
<li>lambda: the ability to define the anonymous tree definitions and invoke it at the same time.</li>
<li>comments: the extra information.</li>
</ul>
<p>Below, a simple example that shows the aforementioned points</p>
<pre><code class="language-f-tree">import "nested/impls.tree"
import "nested/impls.tree" {
    grasp =&gt; grasp_ball,
}

root place_ball_to_target fallback {
    place_to(
        obj = {"x":1 },
        operation = place([10]),
    )
    retry(5) ask_for_help()
}

sequence place_to(what:object, operation:tree){
    fallback {
        is_approachable(what)
        do_job(approach(what))
    }
    fallback {
         is_graspable(what)
         do_job(approach(what))
    }
    sequence {
         savepoint()
         operation(..)
    }
}

sequence place(where:array){
    is_valid_place(where)
    do_job(slowly_drop({"cord":1}))
}

sequence do_job(action:tree){
    savepoint()
    info_wrapper(action(..))
    savepoint()
}

sequence info_wrapper(action:tree){
    log("before action")
    action(..)
    log("before action")
}

impl log(text:string);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>The code of the trees can be organized as a project, breaking down the tree <a href="./definitions.html">definitions</a> into different files.
It enables the project to be organized logically avoiding redundancy.</p>
<p>Therefore, the imports can appear in the file anywhere but are mostly grouped at the top, forming a sort of header.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<h3 id="the-whole-file"><a class="header" href="#the-whole-file">The whole file</a></h3>
<p>To import the whole file, the following syntax needs to be applied:</p>
<pre><code class="language-f-tree">import "nested/impls.tree"
import "/usr/home/projects/impls.tree"
import "C:\projects\forester\tree\tests\plain_project\nested\impls.tree"
</code></pre>
<h3 id="the-definition-with-alias"><a class="header" href="#the-definition-with-alias">The definition with alias</a></h3>
<pre><code class="language-f-tree">import "nested/impls.tree" {
    grasp =&gt; grasp_ball,
}
</code></pre>
<h2 id="import-path"><a class="header" href="#import-path">Import path</a></h2>
<p>The path of the imports can be:</p>
<ul>
<li>absolute : <code>C:\plain_project\nested\impls.tree</code></li>
<li>relative : <code>nested/impls.tree</code></li>
</ul>
<h3 id="absolute-path"><a class="header" href="#absolute-path">Absolute path</a></h3>
<pre><code class="language-f-tree">import "C:\projects\forester\tree\tests\plain_project\nested\impls.tree"
</code></pre>
<h3 id="relative-path"><a class="header" href="#relative-path">Relative path</a></h3>
<p>The relative path relates to the root of the project, that is pointed out in the start.
Typically, the structure is the following:</p>
<pre><code class="language-file">- project_folder
   - main.tree // the file that has a root tree
   - .. folders
   - folder
       - def.tree
   - folder_nested
       - another_nested
           - file.tree    
</code></pre>
<p>Here the import of the <code>file.tree</code> can be</p>
<pre><code>import "folder_nested/another_nested/file.tree"
</code></pre>
<p>in any other file.</p>
<h2 id="aliases"><a class="header" href="#aliases">Aliases</a></h2>
<p>To avoid the problem of ambiguous names when several tree definitions with the same name can be imported,
the aliases can come to the rescue.</p>
<p>They allow renaming tree definition while imports:</p>
<pre><code class="language-f-tree">import "/robot_specific_ops/cv.tree" // has a tree def cv
import "/common_ops/cv.tree" { // also has a tree def cv 
    cv =&gt; com_cv // to avoid ambiguity, we can rename it using an alias.
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-definition"><a class="header" href="#tree-definition">Tree definition</a></h1>
<p>The tree definition denotes a part of the tree (so-called subtree) that defines an independent description and can</p>
<ul>
<li>have the input parameters and accept arguments including other trees definitions</li>
<li>invoke other tree definitions and get invoked by others (except <code>root</code>)</li>
</ul>
<p>There are the following types of the definitions:</p>
<ul>
<li>Flow:
the <a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)#Control_flow_node">core part</a> of the behavior tree framework.
The nodes define a logic of processing the tree itself, navigating for the next step.</li>
<li>Lambda: The anonymous definition of subtree with instant invocation at this place.</li>
<li>Decorator: the atomic built-in tree definition that has one child and can enrich or transform the child result according to its type.</li>
<li>Actions: the leaves of the tree bearing the business logic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-tree-definitions"><a class="header" href="#flow-tree-definitions">Flow tree definitions</a></h1>
<p>The flow tree definitions describe the way how the tree will be traversed.
There are 2 basic types which get broken down afterward:</p>
<ul>
<li>sequences: A Sequence performs every child as long as they are return <code>Success</code>.
If otherwise, the sequence instantly stops with the <code>failure</code> status</li>
<li>fallbacks: A fallback performs children until the first <code>Success</code>.</li>
</ul>
<p>Combining the aforementioned flow trees, we can get any type of logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence"><a class="header" href="#sequence">Sequence</a></h1>
<p>A Sequence node ticks all underlying nodes as long as they return <code>Success</code>.
Otherwise, when a child returns <code>failure</code> the sequence is aborted.</p>
<p>In the language, the tree definitions and lambda invocations of this element are marked with the key word <code>sequence</code>.</p>
<pre><code class="language-f-tree">impl store(key:string, value:string); // store a string value to a key in blackboard

root main {
    sequence {
        store("a","1") // first tick and proceed if succeeded
        store("b","2") // sec tick and proceed if succeeded
        store("c","3") // thrd tick and finish if succeeded
    }
}
</code></pre>
<p>with a graph representation</p>
<pre><code class="language-dot process">strict digraph  {
    1[label="root
main ",shape=rect,color=black]
    1 -&gt; 2
    2[label="sequence",shape=rect,color=darkred]
    2 -&gt; 3
    2 -&gt; 4
    2 -&gt; 5
    3[label="store (key=a,default=1)",shape=component,color=green]
    4[label="store (key=b,default=2)",shape=component,color=green]
    5[label="store (key=c,default=3)",shape=component,color=green]
}
</code></pre>
<h2 id="common-behaviour"><a class="header" href="#common-behaviour">Common behaviour</a></h2>
<ul>
<li>When it gets the first <code>tick</code> it switches to state <code>running</code></li>
<li>When a child returns <code>success</code> it proceeds to the next one and ticks it
<ul>
<li>if this is a final child, it returns <code>success</code></li>
</ul>
</li>
<li>If a child returns <code>running</code>, the node returns <code>running</code> as well</li>
<li>If a child returns <code>failure</code>, the node returns <code>failure</code> as well</li>
<li>When a node is restarted or halted, the process starts from the beginning (see memory sequence for an exception)</li>
</ul>
<h2 id="intention"><a class="header" href="#intention">Intention</a></h2>
<p>Often, it is used as a straight chain of instructions</p>
<pre><code class="language-f-tree">// if the definition has only one child
// (root has only one child) '{''}' can be omitted
root main sequence {
        validate_env()
        perform_action()
        finish_and_save()
}

</code></pre>
<h1 id="subtypes"><a class="header" href="#subtypes">Subtypes</a></h1>
<p>There are 2 subtypes that bring a few subtleties to the common process.</p>
<h2 id="memory-sequence"><a class="header" href="#memory-sequence">Memory Sequence</a></h2>
<p>This sequence defines in the language with the keyword <code>m_sequence</code> and has the following peculiarity:
The sequence memorizes the children that have succeeded and skips them next time.</p>
<pre><code class="language-f-tree">root main {
    retry(5) m_sequence {
        store("key",1)    // returns success
        perform_action()  // returns failure
        finish_and_save()
    }
}
</code></pre>
<p>The node <code>perform_action</code> returns <code>failure</code> and the decorator <code>retry</code> restarts <code>sequence</code>.
The main difference with a sequence is an execution starts from the node <code>perform_action</code> skipping the node <code>store</code>.</p>
<p>This memory persists even if the <code>m_sequence</code> is halted by a reactive flow node. The memory will only be reset once the final action has returned <code>success</code>.
That is, if <code>finish_and_save</code> returns <code>success</code>, the next iteration will start with <code>store</code> again.</p>
<h2 id="reactive-sequence"><a class="header" href="#reactive-sequence">Reactive Sequence</a></h2>
<p>This sequence defines in the language with the keyword <code>r_sequence</code> and has the following peculiarity:
The sequence restarts all children if they return either failure or running.</p>
<pre><code class="language-f-tree">root main {
    r_sequence {
        store("key",1)    // returns success
        perform_action()  // returns running
        finish_and_save()
    }
}
</code></pre>
<p>The node <code>perform_action</code> returns <code>running</code> and the whole sequence returns <code>running</code>
but on the next tick it starts from the node <code>store</code> again.</p>
<p><code>r_sequence</code> will halt the <code>running</code> child to allow a graceful shutdown if a prior child changes from <code>success</code> to <code>failure</code> or <code>running</code>. In the above example, if <code>store</code> returned <code>failure</code> on the second tick then <code>perform_action</code> would be halted before <code>r_sequence</code> returned <code>failure</code> itself.</p>
<p>If <code>store</code> returned <code>running</code> on the second tick then <code>perform_action</code> would also be halted, before potentially being restarted if <code>store</code> then returned <code>success</code> again. Limiting the <code>r_sequence</code> node to a single <code>running</code> child avoids undefined behaviour in nodes that assume they are being run synchronously.</p>
<p>Halting must be performed as quickly as possible. Note that currently only build-in flow, built-in decorator and sync action nodes are halted, async and remote actions are not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallback"><a class="header" href="#fallback">Fallback</a></h1>
<p>A Fallback ticks children sequentially until someone returns a <code>Success</code>.
Otherwise, if all children return <code>Failure</code>, the node returns <code>Failure</code>.</p>
<p>In the language, the tree definitions and lambda invocations of this element are marked with the key word <code>fallback</code>.</p>
<pre><code class="language-f-tree">cond is_busy()
impl take_from_others()

root main  {
    fallback {
        any_tasks() // goes farther if the first actions is failure
        do_it()
    }
}
</code></pre>
<h2 id="common-behavior"><a class="header" href="#common-behavior">Common behavior</a></h2>
<ul>
<li>When it gets the first <code>tick</code> it switches to state <code>running</code></li>
<li>When a child returns <code>success</code> it stops the execution and returns <code>success</code></li>
<li>If a child returns <code>running</code>, the node returns <code>running</code> as well</li>
<li>If a child returns <code>failure</code>, the node proceeds to the next child
<ul>
<li>if this is a final child, it returns <code>failure</code></li>
</ul>
</li>
<li>When a node is restarted or halted the process starts from the beginning</li>
</ul>
<h2 id="intention-1"><a class="header" href="#intention-1">Intention</a></h2>
<p>Often, it is used for making conditions.
The script below emulates a simple condition that needs to do before</p>
<pre><code class="language-f-tree">cond can_take(sub:object)
impl move_to(sub:object)
impl take(sub:object)

root main sequence {
    fallback {
        can_take(item)
        move_to(item)
    }
    take(item)

}
</code></pre>
<p>using a programming language, it could be the following:</p>
<pre><pre class="playground"><code class="language-rust">fn main(item:String){
    if !can_take(item) {
        move_to(item)
    }
    take(item)
}</code></pre></pre>
<h1 id="subtypes-1"><a class="header" href="#subtypes-1">Subtypes</a></h1>
<p>There is one subtype that brings a few subtleties to the common process</p>
<h2 id="reactive-fallback"><a class="header" href="#reactive-fallback">Reactive Fallback</a></h2>
<p>This Fallback defines in the language with the keyword <code>r_fallback</code> and has the following peculiarity:
The fallback restarts all children on the next tick if someone returned <code>running</code>:</p>
<pre><code class="language-f-tree">...
root main {
    r_fallback {
        needs_to_charge()    // returns failure
        action()  // returns running
        fin_and_save()
    }
}
</code></pre>
<p>The node <code>action</code> returns <code>running</code> and the whole sequence returns <code>running</code>
but on the next tick it starts from the node <code>needs_to_charge</code> again.</p>
<p><code>r_fallback</code> will halt the <code>running</code> child to allow a graceful shutdown if a prior child changes from <code>failure</code> to <code>success</code> or <code>running</code>. In the above example, if <code>needs_to_change</code> returned <code>success</code> on the second tick then <code>action</code> would be halted before <code>r_fallback</code> returned <code>success</code> itself.</p>
<p>If <code>needs_to_charge</code> returned <code>running</code> on the second tick then <code>action</code> would also be halted, before potentially being restarted if <code>needs_to_charge</code> then returned <code>failure</code> again. Limiting the <code>r_fallback</code> node to a single <code>running</code> child avoids undefined behaviour in nodes that assume they are being run synchronously.</p>
<p>Halting must be performed as quickly as possible. Note that currently only build-in flow, built-in decorator and sync action nodes are halted, async and remote actions are not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel"><a class="header" href="#parallel">Parallel</a></h1>
<p>A parallel node provides so-called pseudo-parallelism.
It ticks all children sequentially but in one tick.
Therefore, regardless of the result that current child returns the node proceeds to the next one.
The node returns <code>success</code> if all children return <code>success</code> and <code>failure</code> if at least one child returns <code>failure</code>
and <code>running</code> otherwise.</p>
<p>In the language, it is defined with the keyword <code>parallel</code> and has the following syntax:</p>
<pre><code class="language-f-tree">impl store(key:string, value:string); // store a string value to a key in blackboard 

root main {
    parallel {
        store("a","1") // first tick ticks but waits the result 
        store("b","2") // this node will be ticked in the same tick
    }
}
</code></pre>
<h2 id="common-behaviour-1"><a class="header" href="#common-behaviour-1">Common behaviour</a></h2>
<p>In general, it has resemblance to <code>sequence</code> node but with a few differences:</p>
<ul>
<li>When it gets the first <code>tick</code> it switches to state <code>running</code></li>
<li>When a child returns <code>success</code> it proceeds to the next one and ticks it
<ul>
<li>if this is a final child, it returns <code>success</code></li>
</ul>
</li>
<li>If a child returns <code>running</code>, the node proceeds to the next one and ticks it
<ul>
<li>after that the node returns <code>running</code> as well</li>
</ul>
</li>
<li>If a child returns <code>failure</code>, the node proceeds to the next one and ticks it
<ul>
<li>after that the node returns <code>failure</code> as well</li>
</ul>
</li>
<li>When a node is restarted, the process starts from the beginning</li>
</ul>
<h2 id="intention-2"><a class="header" href="#intention-2">Intention</a></h2>
<p>Often, it is used to run two independent (often async) actions</p>
<pre><code class="language-f-tree">root main sequence {
        clean_current_room() // async impl that immidiately returns running  
        prepare_next_room()  // can be sync impl that returns success or failure
}
</code></pre>
<h2 id="peculiarities"><a class="header" href="#peculiarities">Peculiarities</a></h2>
<p>Since the actions are kicked off in the pseudo-parallel manner,
it needs to be aware of the following peculiarities:</p>
<ul>
<li>The order of children is not important. All children will be ticked in the same tick.</li>
<li>The node does wait for the result of all children.</li>
<li>If a child returns <code>running</code> the node will return <code>running</code> as well.</li>
<li>If a child returns <code>failure</code> or <code>success</code> but another child returns <code>running</code> the node will return <code>running</code> as well.
<ul>
<li>The next tick the finished nodes will be skipped and the node will tick the running node.</li>
</ul>
</li>
</ul>
<p><em>The parallel node is not reactive, which means the finished(success or failure) nodes will be skipped in the next tick.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<p>The decorators are the specific type of node,
that transforms the result of its child.
Every decorator has a specific keyword and set of parameters.</p>
<p>** Every decorator should have solely one child **</p>
<h2 id="inverter"><a class="header" href="#inverter">Inverter</a></h2>
<p>The keyword is <code>inverter</code>.
The decorator inverts the result of the child.<br />
<em>Only the final results are inverted, for <code>running</code> the result will be
<code>running</code> as well</em></p>
<pre><code class="language-f-tree">main root sequence {
    inverter check_condition() // inverts the result
}
</code></pre>
<h2 id="forcesuccess"><a class="header" href="#forcesuccess">ForceSuccess</a></h2>
<p>The keyword is <code>force_success</code>.
Always returns <code>success</code> regardless of the child response</p>
<h2 id="forcefail"><a class="header" href="#forcefail">ForceFail</a></h2>
<p>The keyword is <code>force_fail</code>.
Always returns <code>failure</code> regardless of the child response</p>
<h2 id="repeat"><a class="header" href="#repeat">Repeat</a></h2>
<p>The keyword is <code>repeat</code>
It repeats the child so the number of times according to the passing parameter</p>
<ul>
<li>count: the number of repetitions. 0 by default</li>
<li>if the count is 0 the repeat becomes an infinite loop</li>
</ul>
<pre><code class="language-f-tree">// the job will be performed INF times
root main_idle repeat {
    job()
}

// the job will be performed 5 times
root main repeat(5) {
    job()    
}
</code></pre>
<h2 id="retry"><a class="header" href="#retry">Retry</a></h2>
<p>The keyword is <code>retry</code>
If the child returns <code>failure</code>, the decorator tries to run it again.
The number of attempts is restricted by the given argument</p>
<ul>
<li>attempt: the number of repetitions. 0 by default</li>
<li>if the attempt is 0 the Retry becomes an infinite loop</li>
</ul>
<pre><code class="language-f-tree">// 0 by default. will be never failed.
root main retry {
    sequence { 
        job1() 
        job2() 
    }
}

// the decorator will try to repeat the sequence upt to 10 times if it returns failure
root main_with_retry retry(10) {
    sequence { 
        job1() 
        job2() 
    }
}
</code></pre>
<h2 id="timeout"><a class="header" href="#timeout">Timeout</a></h2>
<p>The keyword is <code>timeout</code>
The decorator tries to measure how long the child is running and shut id down if it exceeds the limit.
<strong>For now, it works only for asynchronous actions since the decorator measures time when the child returns <code>running</code></strong></p>
<ul>
<li>limit: the threshold in milliseconds. 1000 by default.</li>
</ul>
<pre><code class="language-f-tree">// if the squence works asynchonously (returns running)
// the timeout will count up the time of the first start 
// and then recheck it every time when the child returns running 
root main_with_retry timeout {
    sequence { 
        job1() 
        job2() 
    }
}
</code></pre>
<h2 id="delay"><a class="header" href="#delay">Delay</a></h2>
<p>The keyword is <code>delay</code>
The decorator delays the initial run of the child for the given as a parameter time.</p>
<ul>
<li>wait: the delay time in milliseconds. 0 by default.</li>
</ul>
<pre><code class="language-f-tree">// the delay is zero
root main delay job()

// the delay is 1 second
root main_d delay(1000) job()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>The leaves of the tree are actions, which are the final point of the whole execution mechanism.
They are supposed to be implemented either using <code>rust</code> or other languages
and mix-in on the execution stage.</p>
<p>The actions have 2 keywords to mark:</p>
<ul>
<li><code>impl</code> means some job or action that can take time and be asynchronous</li>
<li><code>cond</code> means some activity to check some conditions and immediately returns result</li>
</ul>
<p><em>In practice, the engine does not see difference</em></p>
<p>in the language, they can be marked as an operation with empty or lacking implementation.</p>
<pre><code class="language-f-tree">impl action1(a:string); // here the semicolon is required
impl action2(b:object){} // here, not

cond cond1(c:num);
cond cond2(d:array){}

</code></pre>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p><strong>The contract of the definition and invocation should coincide, otherwise the execution will throw an exception</strong></p>
<pre><code class="language-f-tree">impl action(c:num)

root main action() // the exception will be raised since the argument is uncovered.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-actions"><a class="header" href="#built-in-actions">Built-in actions</a></h1>
<p>By default, the framework provides a set of the actions
and conditions that are already implemented.</p>
<p>To use them, the user should import the special file</p>
<pre><code class="language-f-tree">import "std::actions"
</code></pre>
<p>or just a specific definition of the file</p>
<pre><code class="language-f-tree">import "std::actions" {
    store =&gt; store_data,
    fail
}
</code></pre>
<h2 id="file"><a class="header" href="#file">File</a></h2>
<pre><code class="language-f-tree"> //
// Built-in actions. 
// The actions are accessible using the import 'import "std::actions"' 
// Better off, the file be avoided modifying
//

// Fails execution, returning Result::Failure        
impl fail(reason:string);
impl fail_empty();

// Success execution, returning Result::Success  
impl success();

// Running execution, returning Result::Running  
impl running();

// Sleeps on duration(milliseconds) then returns Result::Success
// impl sleep(duration:num);

// Stores the string value in the given key. Returns Result::Success. 
// If the cell is locked, returns Result::Failure   
impl store(key:string, value:string);

// Compares a given value with what is in the cell:
// - Returns Result::Success if they are equal
// - Returns Fail(reason)if they are not equal
// - Returns Fail(reason) if there is no cell in bbe with the given key.
impl equal(key:string, expected:any);

// Store the current tick
impl store_tick(name:string);

// Lock key in bb
impl lock(key:string);

// Unlock key in bb
impl unlock(key:string);

// Performs http get request
impl http_get(url:string, bb_key:string);


</code></pre>
<h1 id="http-server-sync--async"><a class="header" href="#http-server-sync--async">Http server (sync | async)</a></h1>
<h1 id="curl"><a class="header" href="#curl">Curl</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invocations"><a class="header" href="#invocations">Invocations</a></h1>
<p>The language provides the possibility to invoke the definitions
or lambdas in the body of the other definitions</p>
<pre><code class="language-f-tree">
import "std::actions"

impl handle_distance(item:object);

sequence main_seq {
    inverter fail("for test")
    success()
}

sequence check_distance(item:object){
        store("log","start")
        handle_distance(item)
        store("log","end")
}

// definition
root main sequence {
    // invocation
    main_seq()
    
    // another invocation
    check_distance({"x":1,"y":2})
}
</code></pre>
<h2 id="other-types-of-invocation"><a class="header" href="#other-types-of-invocation">Other types of invocation</a></h2>
<p>The other types of invocation are described in the following sections but briefly are:</p>
<ul>
<li>higher order tree invocation: a possibility to pass a tree definition as parameter</li>
<li>lambda invocation: an anonymous definition that creates and gets invoked at the same time.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-tree"><a class="header" href="#higher-order-tree">Higher order tree</a></h1>
<p>The definitions can be passed as arguments in invocations for other definitions.
The definitions should accept <code>tree</code> as a parameter.</p>
<p>To invoke the definition, coming from parameters, the definition should have a name and '(..)' after,
like that:<code>operation(..)</code></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>To reduce the amount of redundancy in implementing some logic.
The higher order tree enables to construct abstractions that will be easily
used in the next tree definitions reducing the amount of code.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-f-tree">...

// the checked_task declares acceptance of 2 tree definitions
fallback checked_task(cond:tree, task:tree){
    // invoke a tree definition from parameters
    cond(..)
    // invoke a tree definition from parameters
    task(..)
}

sequence handle(item:object) {
    // higher order invocation in arguments
    checked_task(close_enough(item), approach(item))
    checked_task(is_graspable(item), grasp(item))
    // The lambdas can be used as higher-order tree as well
    checked_task(enough_space(item), sequence {
        move(item)
        save(tem)
    })
}
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>For now, the tree does not perform the parameter capturing.
It means the following:</p>
<ul>
<li>static constants are passed as is</li>
<li>pointers are resolved at the moment of invocation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda"><a class="header" href="#lambda">Lambda</a></h1>
<p>The anonymous definitions can be defined and instantly invoked at the same time.
The definitions are unique and every time the new definition is created.</p>
<ul>
<li>They don't have a name</li>
<li>They are unique</li>
<li>They don't have arguments</li>
</ul>
<p><strong>Only the elements of <a href="./flow.html">Flow</a>  can be used in lambdas</strong>
<strong>The actions always have to be defined explicitly.</strong></p>
<pre><code class="language-f-tree">impl job();

root main {
    // lambda invocation
    sequence {
        job()
        job()
        job()
    }
    // another lambda invocation
    fallback {
        sequence {
            job()
            job()   
        }
        // the second level of lambda
        sequence {
            job()
            // also lambda, but the backets are omitted. 
            r_sequence job()
        }
    }

}
</code></pre>
<h2 id="parameter"><a class="header" href="#parameter">Parameter</a></h2>
<p>Lambda can be used as parameters as well.</p>
<pre><code class="language-f-tree">impl savepoint();
impl job();

sequence wrapper(item:tree){
    savepoint()
    item(..)
    savepoint()
}

root main sequence {
    wrapper(
        sequence {
            job()
            job()
            job()
        }
    )
    wrapper(
        item = 
            fallback {
                job()
                job()
                job()
            }
    )
    
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h1>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li>Parameters are elements of tree definitions.</li>
<li>Arguments are elements of tree invocations.</li>
</ul>
<pre><code class="language-f-tree">// parameters 'a' and 'b'
sequence tree(a:string,b:num){
    // arguments 'c', 'd'
    job(c = 1, d = "d")
}
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>Therefore, the arguments represent the attachments of the real value to the parameters.
The Argument can be one of two types:</p>
<ul>
<li>Named argument</li>
<li>Unnamed argument</li>
</ul>
<pre><code class="language-f-tree">impl action(a:string, b:num)

root main sequnce {
    // Named Arguments
    action(a="a",b:1)
    
    // Unnamed Arguments
    action("a",1)
}
</code></pre>
<p><strong>There is impossible to mix named and unnamed arguments</strong>
The following code will have an error during the compilation process.</p>
<pre><code class="language-f-tree">impl action(a:string, b:num)
root main sequnce {
    action("a",b=1 )
}
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="number"><a class="header" href="#number">Number</a></h3>
<p>The numbers are defined with a keyword <code>num</code>
There are 4 possible types of numbers presented:</p>
<ul>
<li>Integers(64)</li>
<li>Floats(64)</li>
<li>Hex</li>
<li>Binary</li>
</ul>
<p><strong>In case of exceeding the maximum value, the error will be raised on the compile time.</strong></p>
<pre><code class="language-f-tree">impl action(param:num)

root main sequence {
    // Integers
    action(1)
    action(10e2)
    action(-1)
    action(0)
    
    // Floats
    action(0.0)
    action(100.0e1)
    action(-100.0)
    
    // Hex
    action(0x123)
    
    // Binary
    action(0b010101)
}
</code></pre>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>The strings are defined with <code>string</code></p>
<pre><code class="language-f-tree">impl action(param:string)
root main action(param = "X")
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>The booleans are defined with a keyword <code>bool</code> and has the following parameters:</p>
<ul>
<li><code>true</code> for the positive statement</li>
<li><code>false</code> for the negative statement</li>
</ul>
<pre><code class="language-f-tree">impl action(param:bool);
root main action(true)
</code></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>The arrays are defined with keyword <code>array</code>
Arrays can have several aforementioned elements encompassed in one entity.</p>
<p>The arrays have the following syntax:</p>
<ul>
<li><code>[</code> defines the start of array</li>
<li><code>]</code> defines the end of array</li>
<li><code>,</code> defines the separator between elements</li>
<li>the rest is defined by the particular elements</li>
</ul>
<p><strong>It is expected, the arrays are homogeneous and have all elements only one type</strong></p>
<p><strong>The arrays can have a trailing comma as well, <code>[1,]</code></strong></p>
<pre><code class="language-f-tree">impl action(elems:array);
root main sequence {
    action([1,2,3,4])
    action([1.1,0.1])
    action(["a","b"])
}
</code></pre>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>The objects are defined with keyword <code>object</code>
Objects can have several aforementioned elements encompassed
in one entity with the unique key attached to the every entity</p>
<p>The objects have the following syntax:</p>
<ul>
<li><code>{</code> defines the start of object</li>
<li><code>}</code> defines the end of object</li>
<li><code>,</code> defines the separator between elements</li>
<li>"key" defines the name of the element key</li>
<li>the rest is defined by the particular elements</li>
</ul>
<p><strong>The objects can have a trailing comma as well, <code>{"a":1,}</code></strong></p>
<pre><code class="language-f-tree">impl action(elems:object);
root main sequence {
    action({"key":1, "key2":"key"})
    action(
        {
            "array": [1,2,3,4,],
            "string":"string",
            "num":1,
            "pointer": pointer
        }
    )
}
</code></pre>
<h3 id="tree"><a class="header" href="#tree">Tree</a></h3>
<p>The other tree definitions are defined with a keyword <code>tree</code>
**The parameters of this type can be added and defined only in the <a href="./flow.html">flow</a> definitions.</p>
<pre><code class="language-f-tree">impl log(id:string,info:string);
cond check();
cond task();

fallback checked_task(check:tree, task:tree){
    check(..)
    task(..)
}

sequence logged_task(id:string, task:tree){
    log(id,"start task")
    task(..)
    log(id,"end task")
}

root main sequence {
    // invoke the task parameter, passing the invokations with parameters 
    logged_task(
        "1",
        // invoke the task, passing the invokations with parameters
        checked_task(check = check(), task())
    )
}
</code></pre>
<h3 id="pointers"><a class="header" href="#pointers">Pointers</a></h3>
<p>Pointers are identifiers of the objects in the <a href="./bb.html">BlackBoard</a>
Therefore, they can be used to obtain the value of the cell from bb, in argument invoking.</p>
<p>In the example below, the system expects to find a string value in the cell with a name <code>bb_key</code>.</p>
<pre><code class="language-f-tree">impl action(value:string);

root main sequence {
    // this is a pointer to a cell in bb with an id 'bb_key'
    action(bb_key) 
}
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p>The <code>any</code> type is a special type that can be used to pass any type of value to the parameter.</p>
<p><strong>The type any can take any message type except call</strong></p>
<p>The intention to provide a simple way to generalize the parameters and pass any type of value to the parameter.</p>
<pre><code class="language-f-tree">// can take anything except call
impl action(value:any);

root main sequence {
    
    action(1) 
    action("a") 
    action([1]) 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="antlr-grammar"><a class="header" href="#antlr-grammar">Antlr grammar</a></h1>
<p>The grammar bears an introducing character (means it is not used straight in the code for now)</p>
<h2 id="parser"><a class="header" href="#parser">Parser</a></h2>
<pre><code class="language-antlrv4">parser grammar TreeParser;

file
    : (definition | importSt)* EOF
    ;

import_name
    : id (EQ_A id)?
    ;

importCalls
    : LBC (import_name (COMMA import_name)* COMMA?)? RBC
    ;

importSt
    : IMPORT string importCalls?
    ;

definition
    : tree_type id params? (calls? | SEMI)
    ;

call
    : invocation
    | lambda
    ;

invocation
    : id (args | LPR DOT_DOT RPR)
    ;


lambda
    : tree_type args? calls
    ;

calls
    : LBC call* RBC
    | call
    ;


arg
    : id (EQ (message | id | call))?
    | message
    | call
    ;

args
    : LPR (arg (COMMA arg)* COMMA?)? RPR
    ;

params
    : LPR (param (COMMA param)*)? COMMA? RPR
    ;

param
    : id COLON mes_type
    ;

message
    : string
    | num
    | bool
    | array
    | object
    ;

mes_type
    : NUM_T
    | ARRAY_T
    | OBJECT_T
    | STRING_T
    | BOOL_T
    | TREE_T
    ;

tree_type
    : ROOT
    | PARALLEL
    | SEQUENCE
    | MSEQUENCE
    | RSEQUENCE
    | FALLBACK
    | RFALLBACK
    | id          // ambigulty
    ;


object
    : LBC (objectPair (COMMA objectPair)* COMMA? )? RBC
    ;

objectPair
    : string COLON message
    ;


array
    : LBR (message (COMMA message)* COMMA? )? RBR
    ;

bool
    : TRUE
    | FALSE
    ;

num
    : NUMBER
    ;

string
    : STRING
    ;
id
    : ID
    ;
</code></pre>
<h2 id="lexer"><a class="header" href="#lexer">Lexer</a></h2>
<pre><code class="language-antlrv4">lexer grammar TreeLexer;

ROOT: 'ROOT';
PARALLEL : 'parallel';

SEQUENCE : 'sequence';
MSEQUENCE : 'm_sequence';
RSEQUENCE : 'r_sequence';

FALLBACK: 'fallback';
RFALLBACK : 'r_fallback';

ARRAY_T: 'array';
NUM_T: 'num';
OBJECT_T: 'object';
STRING_T: 'string';
BOOL_T: 'bool';
TREE_T: 'tree';
IMPORT: 'import';

ID : [-_a-zA-Z]+ (INT | [-_a-zA-Z]+)*  ;

COMMA : ',';
COLON : ':';
SEMI : ';';
DOT_DOT : '..';

EQ  : '=';
EQ_A  : '=&gt;';

LPR  : '(';
RPR  : ')';

LBC  : '{';
RBC  : '}';

LBR  : '[';
RBR  : ']';

TRUE : 'TRUE';

FALSE : 'FALSE';

STRING  : '"' (ESC | SAFECODEPOINT)* '"' ;

NUMBER  : '-'? INT ('.' [0-9] +)? EXP? ;

Whitespace: [ \t]+ -&gt; skip ;

Newline :   (   '\r' '\n'? | '\n') -&gt; skip ;

BlockComment :   '/*' .*? '*/' -&gt; skip ;

LineComment :   '//' ~[\r\n]* -&gt; skip ;

fragment ESC : '\\' (["\\/bfnrt] | UNICODE) ;

fragment UNICODE : 'u' HEX HEX HEX HEX ;
fragment HEX : [0-9a-fA-F] ;

fragment SAFECODEPOINT : ~ ["\\\u0000-\u001F] ;
fragment INT : '0' | [1-9] [0-9]* ;
fragment EXP : [Ee] [+\-]? [0-9]+ ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-engine"><a class="header" href="#runtime-engine">Runtime engine</a></h1>
<p>The runtime part executes the given tree.</p>
<p>There are 3 major components of the engine part</p>
<ul>
<li>Engine itself (Forester)</li>
<li>Blackboard</li>
<li>Actions(including ActionKeeper)</li>
</ul>
<p>The runtime is predominantly synchronous with asynchronous environment for the async actions.
The blackboard is in-memory for now.</p>
<h2 id="general-api"><a class="header" href="#general-api">General api</a></h2>
<p>The entry point is a <code>ForesterBuilder</code> that allows to build <code>Forester</code> in a safe way.
Also, it is highly customizable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> use std::path::PathBuf;
 use forester::tracer::Tracer;
 use forester::runtime::builder::ForesterBuilder;
 use forester::runtime::action::Action;
 use forester::runtime::action::builtin::data::StoreData;
 use forester_rs::runtime::action::builtin::data::StoreData;
 use forester_rs::runtime::builder::ForesterBuilder;
 use forester_rs::tracer::Tracer;
 
fn test(root:PathBuf){
     let mut root = PathBuf::new();

     let mut fb = ForesterBuilder::new();
     fb.main_file("main.tree".to_string());
     fb.root(root);
     fb.register_action("store", Action::sync(StoreData));
     
     fb.tracer(Tracer::default());
     fb.bb_load("db/db.json".to_string());
     let forester = fb.build().unwrap();
     
     let r = forester.run().unwrap();
 }


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine-1"><a class="header" href="#engine-1">Engine</a></h1>
<p>The runtime engine of the framework is <code>Forester</code>.
It encompasses several components:</p>
<ul>
<li>Blackboard</li>
<li>ActionKeeper</li>
<li>Runtime Env</li>
<li>Tracer</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> use std::path::PathBuf;
 use forester::tracer::Tracer;
 use forester::runtime::builder::ForesterBuilder;
 use forester::runtime::action::Action;
 use forester::runtime::action::builtin::data::StoreData;
 use forester_rs::runtime::action::Action;
 use forester_rs::runtime::action::builtin::data::StoreData;
 use forester_rs::runtime::builder::ForesterBuilder;
 use forester_rs::tracer::Tracer;
 fn test(root:PathBuf){
     let mut root = PathBuf::new();

     let mut fb = ForesterBuilder::new();
     fb.main_file("main.tree".to_string());
     fb.root(root);
     fb.register_action("store", Action::sync(StoreData));
     
     fb.tracer(Tracer::default());
     fb.bb_load("db/db.json".to_string());
     let forester = fb.build().unwrap();
     
     forester.run(); //  forester.run_until( Some(100));
 }

<span class="boring">}</span></code></pre></pre>
<h2 id="tick-limitation"><a class="header" href="#tick-limitation">Tick limitation</a></h2>
<p><code>Forester</code> allows limiting how many ticks will be done by running <code>run_with(Some(number))</code></p>
<h2 id="runtime-environment"><a class="header" href="#runtime-environment">Runtime environment</a></h2>
<p>The framework uses <code>tokio</code> as a platform to orchestrate threads and parallelize the job.
By default, it creates its own tokio runtime env.
Nevertheless, if there is existing env, it can be provided in <code>ForesterBuilder</code></p>
<h2 id="http-server"><a class="header" href="#http-server">Http Server</a></h2>
<p>The server provides an option to set up the http server to interact with the tree.
The server exposes the access to the blackboard and the tracer.</p>
<p>To turn on the server, it is required to provide the port number in the <code>ForesterBuilder</code>.
<em>When the forester finishes the execution of the tree, the server will be shut down.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn serv(fb:ForesterBuilder){
     fb.http_serv(10000); // the port then will be sent to the remote actions as well
 }
<span class="boring">}</span></code></pre></pre>
<h2 id="the-api"><a class="header" href="#the-api">The API</a></h2>
<p>The server exposes the following endpoints:</p>
<ul>
<li><code>GET /tracer/print</code> - print the tracer</li>
<li><code>POST /tracer/custom</code> - add a custom message to the tracer. It accepts the json body with <code>CustomEvent</code></li>
<li><code>GET /bb/:key/lock</code> - lock the key</li>
<li><code>GET /bb/:key/unlock</code> - unlock the key</li>
<li><code>GET /bb/:key/locked</code> - check if the key is locked</li>
<li><code>GET /bb/:key/contains</code> - check if the key is in the bb</li>
<li><code>GET /bb/:key/take</code> - take the key from the bb</li>
<li><code>POST /bb/:key</code> - put the key to the bb. It accepts the json body from <code>RtValue</code></li>
<li><code>GET /bb/:key</code> - get the key from the bb</li>
<li><code>GET /</code> - health check. Returns 'Ok'</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-arguments"><a class="header" href="#runtime-arguments">Runtime arguments</a></h1>
<p>The runtime representation of the static arguments from the code.
It has the same set of types and easily transforms one to another</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum RtValue {
    String(String),
    Bool(bool),
    Array(Vec&lt;RtValue&gt;),
    Object(HashMap&lt;String, RtValue&gt;),
    Number(RtValueNumber),
    Pointer(BBKey)
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h3>
<p>The types <code>String</code>, <code>Bool</code>, <code>Number</code> are primitive types. They act as their counterparts in the other languages</p>
<h3 id="complex-types"><a class="header" href="#complex-types">Complex types</a></h3>
<p>The types <code>Object</code> acts as a json map and <code>Array</code> just as an array.</p>
<h3 id="pointer"><a class="header" href="#pointer">Pointer</a></h3>
<p>Represents a name of the cell in bb. For example, in the expression <code>equal(tick, 10)</code> the tick is a pointer and represents
a name of the cell where the value is stored. Thus, the action will go to the cell <code>tick</code> and extract the value and compare
it with number.</p>
<pre><code class="language-f-tree">import "std::actions"
impl incr(k:string, i:num);

root main r_sequence{
    store_tick("tick")
    sequence {
        r_fallback {
            equal(tick, 10)
            running()
        }
    }
}

</code></pre>
<p>Remark.
The action <code>store_tick("tick")</code> accepts a cell name as a string,
otherwise if it is a pointer the action will be looking a name inside the cell with the name <code>tick</code>.
The example depicts it:</p>
<pre><code>    store("x","tick")
    store_tick(x)
    equal(tick, 10)
</code></pre>
<h3 id="how-to-work-with-arguments"><a class="header" href="#how-to-work-with-arguments">How to work with arguments</a></h3>
<p>There are two ways to extract the values from the arguments:</p>
<h4 id="directly-using-as_-method"><a class="header" href="#directly-using-as_-method">Directly using as_<type> method</a></h4>
<p>Every argument can be immediately converted to the specific primitive or complex type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to(v:RtValue) {
    let val:Option&lt;String&gt; = v.as_string();
}
<span class="boring">}</span></code></pre></pre>
<p>This is the cheapest way to do it. But also, this way does not consider pointers,
therefore, it can be used only if you are sure the type is primitive or complex.</p>
<h4 id="using-castctx-method"><a class="header" href="#using-castctx-method">Using cast(ctx) method</a></h4>
<p>The method accepts context for being able to unfold the pointer if it is presents.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Impl for CheckEq {
    fn tick(&amp;self, args: RtArgs, ctx: TreeContextRef) -&gt; Tick {
        let key = args
            .find_or_ith("key".to_string(), 0)
            .ok_or(RuntimeError::fail(format!("the key is expected ")))?;
        
        // cast accepts a context to be able to resolve pointers if they are presented
        let param = key.cast(ctx.clone()).str()?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is method preferable if you are not sure what can come in the arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blackboard-1"><a class="header" href="#blackboard-1">Blackboard</a></h1>
<p>Blackboard represents a memory layer that enables to store and get the data, lock and take it.
By default, it works in memory.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>Blackboard preserves the pairs of <code>String</code> and <code>BBValue</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BBValue {
    Locked(RtValue),
    Unlocked(RtValue),
    Taken,
}
<span class="boring">}</span></code></pre></pre>
<p>where <code>Locked</code> means the value is locked for everything,
<code>Unlocked</code> a normal value enables to read, write and other actions,
<code>Taken</code> means the key exists but the value is taken from the Blackboard.</p>
<h3 id="load-and-dump"><a class="header" href="#load-and-dump">Load and dump</a></h3>
<p>The Blackboard enables to <code>dump</code> the snapshot to the disk
or print it and <code>load</code> the initial configuration from a file, see <code>ForesterBuilder</code> for details.</p>
<ul>
<li>dump: Drops the snapshot to the file in json format.</li>
<li>print_dump: Prints the snapshot to the stdout in json format.</li>
<li>text_dump: Returns the snapshot in json format.</li>
<li>load: Loads the snapshot from the file in json format.</li>
</ul>
<h2 id="utils"><a class="header" href="#utils">Utils</a></h2>
<p>A set of extra helper methods for the Blackboard is available in the <code>utils</code>
module for instance <code> blackboard::utils::push_to_arr</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions-1"><a class="header" href="#actions-1">Actions</a></h1>
<p>Actions are the leaves of the tree. They require some implementation to be executed.</p>
<h2 id="action-types"><a class="header" href="#action-types">Action types</a></h2>
<p>There are three types of actions available at that moment:</p>
<ul>
<li>
<p>Sync actions: the actions that block the flow until the action get done.</p>
</li>
<li>
<p>Async action: initiate the calculation at the different thread and return <code>running</code> immediately.</p>
</li>
<li>
<p>Remote action: send the blocking request (http) to the remote host.</p>
</li>
<li>
<p>For heavy actions, preferably to use <code>async actions</code>.</p>
</li>
</ul>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The action trait implements two functions, <code>tick()</code> and <code>halt()</code>.</p>
<p>The <code>tick()</code> function is the main entry point of the action and will be called whenever the node is executed.</p>
<p>The <code>halt()</code> function is used to notify a <code>running</code> action that a reactive flow node (e.g. <code>r_sequnce</code>) has changed the control flow. This means the previously <code>running</code> action won't be called again, or won't be called for a while, and so should gracefully clean up. The <code>halt()</code> function has a default no-op implementation that can be used if no clean up is necessary.</p>
<p>Actions must halt as quickly as possible, and the call to <code>halt()</code> should not block the execution.</p>
<h3 id="impl-for-sync-actions"><a class="header" href="#impl-for-sync-actions"><code>Impl</code> for sync actions</a></h3>
<p>Sync actions are the only actions that currently implement the <code>halt()</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Impl {
    fn tick(&amp;self, args: RtArgs, ctx: TreeContextRef) -&gt; Tick;

    fn halt(&amp;self, args: RtArgs, ctx: TreeContextRef) -&gt; RtOk {
        // Default halt is a no-op function.
        let _ = args;
        let _ = ctx;
        Ok(())
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="implasync-for-async-actions"><a class="header" href="#implasync-for-async-actions"><code>ImplAsync</code> for async actions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ImplAsync: Sync + Send {
    fn tick(&amp;self, args: RtArgs, ctx: TreeContextRef) -&gt; Tick;
}
<span class="boring">}</span></code></pre></pre>
<p>Where <code>args</code> are the given arguments from the tree definition and invocation and <code>ctx</code>
is a reference of the invocation context with <code>bb</code> and <code>tracer</code>.</p>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>The actions are intentionally stateless thus they can't mutate.
Therefore, it is better off to use blackboard to keep some data between the calls.</p>
<h2 id="how-to-register-action"><a class="header" href="#how-to-register-action">How to register action</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn simple_delay() {
    let mut forester_builder = fb("decorators/simple_delay");

    forester_builder.register_sync_action("store", StoreData);

}
<span class="boring">}</span></code></pre></pre>
<h2 id="async-actions"><a class="header" href="#async-actions">Async actions</a></h2>
<p>The async actions are executed in the multithreading environment and return the <code>running</code> tick result instantly.
It does not block the execution of the tree and can be used in parallel nodes, etc.</p>
<p>On the other hand, every time when the tree is reloaded, the tick number is increased that can exceed the limit on ticks
if the system has it. Therefore, it needs to take into account (when forester runs with the limit of ticks.)</p>
<h2 id="remote-actions"><a class="header" href="#remote-actions">Remote actions</a></h2>
<p>The remote actions are the actions that send the request to the remote host and wait for the response.
For now, it is only http requests with json body and json response.</p>
<p>The remote actions can have access to the blackboard and the tracer if the http-server is running (see <a href="./engine.html#http-server">http-server</a>).</p>
<p>The remote actions should implement <code>ImplRemote</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait ImplRemote: Sync + Send {
    fn tick(&amp;self, args: RtArgs, ctx: TreeRemoteContextRef) -&gt; Tick;
}
<span class="boring">}</span></code></pre></pre>
<p>Where <code>args</code> are the given arguments from the tree definition and invocation and <code>ctx</code> has the information about the http_server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TreeRemoteContextRef&lt;'a&gt; {
    pub curr_ts: Timestamp, // current timestamp
    pub port: u16,          // port of the http server, to access the blackboard and tracer
    pub env: &amp;'a mut RtEnv, // runtime env to execute the http request
}
<span class="boring">}</span></code></pre></pre>
<p>The default implementation of the <code>tick</code> method is available in <code>forester_rs::runtime::action::builtin::remote::RemoteHttpAction</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RemoteHttpAction {
    url: String,
    serv_ip: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>it accepts the url and the ip of the http server (if it is not localhost, which is a default parameter).</p>
<p>The message is the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RemoteActionRequest {
    pub tick: usize,            // current tick
    pub args: Vec&lt;RtArgument&gt;,  // arguments from the tree
    pub serv_url: String,       // url of the http server to get access to the blackboard and tracer
}
<span class="boring">}</span></code></pre></pre>
<p>The response is the following a <code>TickResult</code>.</p>
<p>How to implement the client side, please see <a href="./rem_action.html">remote action lib</a>.</p>
<h2 id="default-actions"><a class="header" href="#default-actions">Default actions</a></h2>
<p>By default, there are several implementations for http and interactions with bb are available in</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use forester_rs::runtime::action::builtin::*;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trimming"><a class="header" href="#trimming">Trimming</a></h1>
<p>The engine provides a simple way to change the runtime tree or other components on a fly during the execution.</p>
<h2 id="the-premises-of-trimming"><a class="header" href="#the-premises-of-trimming">The premises of trimming</a></h2>
<p>Why do we need to have this process?</p>
<h3 id="performanceoptimization-tasks"><a class="header" href="#performanceoptimization-tasks">Performance/Optimization tasks</a></h3>
<p>The execution can be optimized from the performance/memory point of view as JIT compilers act.
Thus, it enables the transformation of the execution folding/caching of some nodes.</p>
<h3 id="logical-tasks"><a class="header" href="#logical-tasks">Logical tasks</a></h3>
<p>When the execution needs to be changed according to some logical premises or incentives based on the runtime
information (like a process of reinforcement learning)</p>
<h3 id="research-tasks"><a class="header" href="#research-tasks">Research tasks</a></h3>
<p>The possibility to perform research on how the process can be changed in case to compare the results in the same
environment.</p>
<h2 id="the-structure-of-trimming"><a class="header" href="#the-structure-of-trimming">The structure of Trimming</a></h2>
<p>The trimming consists of several simple components:</p>
<h3 id="trimming-task"><a class="header" href="#trimming-task">Trimming task</a></h3>
<p>A task that will be executed.
Typically, the task can decide whether it needs to be postponed, rejected or get to execute.
The implementation touches the different components like trimming of a runtime tree.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TrimTask {
    RtTree(Box&lt;dyn RtTreeTrimTask&gt;),
}

impl TrimTask {
    /// the main method to execute
    pub fn process(&amp;self, snapshot: TreeSnapshot&lt;'_&gt;) -&gt; RtResult&lt;TrimRequest&gt; {..}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trimrequest"><a class="header" href="#trimrequest">TrimRequest</a></h3>
<p>A request to trim. Since, there are no guarantees of the specific order of the different tasks or even the moment of time (in terms of ticks)
when it will be executed (for instance, the nodes that this task tries to trim are running and therefore this task will be postponed),
the request has influence on the possible execution of itself.</p>
<p>The possible states:</p>
<ul>
<li>Reject: The task can reject itself, when it finds out that, for instance, another task performed the same changed
or made the tree unsuitable for the current changes.</li>
<li>Skip: Skip the current tick. When the conditions are inappropriate.
For instance, the task waits for a specific data in bb or a particular tick or anything else.</li>
<li>Attempt: Attempt to trim</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum TrimRequest {
    Reject,
    Skip,
    Attempt(RequestBody),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="requestbody"><a class="header" href="#requestbody">RequestBody</a></h3>
<p>Just a structure that bears all changes of the request.</p>
<h3 id="validations"><a class="header" href="#validations">Validations</a></h3>
<p>Under the hood, the engine tries to validate a given request and ensure that the tree will not be corrupted.
For now, it performs only the check if the nodes of the tree that are about to be replaced are not running.</p>
<h2 id="constrains"><a class="header" href="#constrains">Constrains</a></h2>
<p>There is no way to foresee and guarantee the possible order or the possible moment when the trimming task will be executed,
or even will it be executed at all, therefore, better to pursue to create the task idempotent and validate the incoming state diligently.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> use forester_rs::*;
 use forester_rs::runtime::forester::Forester;
 use forester_rs::runtime::rtree::builder::RtTreeBuilder;
 use forester_rs::runtime::RtResult;
 use forester_rs::runtime::trimmer::task::{RtTreeTrimTask, TrimTask};
 use forester_rs::runtime::trimmer::{RequestBody, TreeSnapshot, TrimRequest};
 use forester_rs::runtime::rtree::builder::RtNodeBuilder;
 use forester_rs::runtime::rtree::rnode::RNodeName;
 use forester_rs::runtime::args::RtArgs;

 fn smoke(mut forester: Forester) {

     forester.add_trim_task(TrimTask::rt_tree(Test));
     let result = forester.run_until(Some(100)).unwrap();
     println!("{}",result);
 }

 struct Test;

 // just take a not and manually replace it.
 impl RtTreeTrimTask for Test {
     fn process(&amp;self, snapshot: TreeSnapshot&lt;'_&gt;) -&gt; RtResult&lt;TrimRequest&gt; {
         if snapshot.tick &lt; 90 {
             Ok(TrimRequest::Skip)
         } else {
             let tree = snapshot.tree;
             let id = tree
                 .nodes
                 .iter()
                 .find(|(_, n)| {
                     n.name()
                         .and_then(|n| n.name().ok())
                         .filter(|n| n.as_str() == "fail_empty")
                         .is_some()
                 })
                 .map(|(id, _)| id)
                 .unwrap();
             let mut rtb = RtTreeBuilder::new_from(tree.max_id() + 1);
             rtb.set_as_root(action!(node_name!("success")), id.clone());

             Ok(TrimRequest::attempt(RequestBody::new(
                 rtb,
                 Default::default(),
             )))
         }
     }
 }



<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="daemons"><a class="header" href="#daemons">Daemons</a></h1>
<p>Forester provides the conception of the background processes called daemons. <br />
Daemons are used to perform some actions in the background. <br />
For example, it can be used to publish some messages  or subscribe to the topics from the external system <br />
or to perform some actions on the blackboard in the background.</p>
<p><em>The daemons are executed at the same runtime environment
as a tree thus the daemons can affect the performance of the tree directly.</em></p>
<h2 id="daemon-definition"><a class="header" href="#daemon-definition">Daemon definition</a></h2>
<p>The enum <code>Daemon</code> encapsulates a daemon function and provides the following variants:</p>
<ul>
<li>sync - the daemon function is synchronous and will be wrapped into async function.</li>
<li>async - the daemon function is asynchronous and will be executed as is.</li>
</ul>
<h2 id="how-to-stop-the-daemon"><a class="header" href="#how-to-stop-the-daemon">How to stop the daemon</a></h2>
<p>Since, the daemon is supposed to be a long-living background process, there is no way to predict when it will be stopped. <br />
Therefore, depending on the daemon type, the engine provides the following ways to stop the daemon:</p>
<h3 id="sync-daemon"><a class="header" href="#sync-daemon">Sync daemon</a></h3>
<p>The sync daemon function accepts the <code>StopSignal</code> as an argument. <br />
The <code>StopSignal</code> is a simple atomic boolean that initially false and when it switches to true, the daemon should be stopped.</p>
<h3 id="async-daemon"><a class="header" href="#async-daemon">Async daemon</a></h3>
<p>The async daemon function accepts the <code>CancellationToken</code> as an argument. <br />
The <code>CancellationToken</code> is a mechanism from tokio that allows to stop the async function.(one shot channel)</p>
<h2 id="examples-of-the-daemon"><a class="header" href="#examples-of-the-daemon">Examples of the daemon</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DaemonSync;

impl DaemonFn for DaemonSync {
    fn perform(&amp;mut self, ctx: DaemonContext, signal: StopFlag) {
        while !signal.load(Relaxed) {
            std::thread::sleep(std::time::Duration::from_millis(50));
            let mut bb = ctx.bb.lock().unwrap();
            let v = bb.get("test".to_string()).expect("no errors")
                .cloned().unwrap_or(RtValue::int(0));

            bb.put("test_daemon".to_string(), v).unwrap();
        }
    }
}

impl AsyncDaemonFn for DaemonSync {
    fn prepare(&amp;mut self, ctx: DaemonContext, signal: CancellationToken) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output=()&gt; + Send&gt;&gt; {
        Box::pin(async move {
            loop {
                tokio::select! {
                _ = signal.cancelled() =&gt; {
                    return;
                }
                _ = tokio::time::sleep(std::time::Duration::from_millis(10)) =&gt; {
                    let mut bb = ctx.bb.lock().unwrap();
                    let v = bb.get("test".to_string()).expect("no errors")
                        .cloned().unwrap_or(RtValue::int(0));

                    bb.put("test_daemon".to_string(), v).unwrap();
                }
            }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="daemon-registration"><a class="header" href="#daemon-registration">Daemon registration</a></h2>
<p>The daemon can be registered as follows:</p>
<h3 id="using-the-tree-builder"><a class="header" href="#using-the-tree-builder">Using the tree builder</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn register(fb:ForesterBuilder){
    let signal = Arc::new(AtomicBool::new(false));
    fb.register_named_daemon("daemon".to_string(), Daemon::sync(DaemonSync));
    fb.register_daemon(DaemonSync(signal));
}


<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-runtime-environment"><a class="header" href="#using-the-runtime-environment">Using the runtime environment</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Impl for Action {
    fn tick(&amp;self, args: RtArgs, ctx: TreeContextRef) -&gt; Tick {
        let env = ctx.env().lock()?;
        env.start_daemon(Daemon::a_sync(DaemonSync), ctx.into());
        Ok(TickResult::success())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="builtin-actions"><a class="header" href="#builtin-actions">BuiltIn actions</a></h2>
<p>There are 2 built-in actions that can be used to control the daemons:</p>
<ul>
<li><code>stop_daemon</code> - stops the daemon by the name</li>
<li><code>daemon_alive</code> - check if the daemon is alive by the name</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-1"><a class="header" href="#analysis-1">Analysis</a></h1>
<p>The framework provides a set of tools and methods to analyze the trees.</p>
<ul>
<li>Visualization: The framework uses graphviz to visualize the tree in svg format.</li>
<li>Tracing: The tracing enables to see how the tree is traversed step by step.</li>
<li>Simulation: The simulation enables to replace the real implementations with a small stubs and run the tree.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualization-1"><a class="header" href="#visualization-1">Visualization</a></h1>
<p>The engine provides the ability to visualize a given project.</p>
<h2 id="precausions"><a class="header" href="#precausions">Precausions</a></h2>
<p>To get it worked locally, the <a href="https://graphviz.org/download/">graphviz</a> should be installed,
since the visualizations uses it under the hood.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p><img src="./pics/amr_simple.svg" alt="amr_simple.svg" /></p>
<h2 id="how-to-use"><a class="header" href="#how-to-use">How to use</a></h2>
<h3 id="console-utility"><a class="header" href="#console-utility">Console utility</a></h3>
<pre><code class="language-shell">f-tree vis --root project/ --main main.tree --tree main --output viz.svg
</code></pre>
<ul>
<li>root can be ommited, the <code>&lt;pwd&gt;</code> folder will be taken by default</li>
<li>main can be ommited, by default, the name <code>main.tree</code> will be taken.</li>
<li>tree can be ommited if only one root definition in the file</li>
<li>output can be ommited, by default, the name of the main file will be taken but the extention will be <code>svg</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing-1"><a class="header" href="#tracing-1">Tracing</a></h1>
<p>By default, the engine tries to trace the information about the tree.
It can be helpful in analyzing.</p>
<p>Below, the example how it can be shown in a text form:</p>
<pre><code class="language-text">[1]  1 : Running(cursor=0,len=1)
[1]    2 : Running(cursor=0,len=3)
[1]      3 : Success(key=x,value=tick)
[1]    2 : Running(cursor=1,len=3)
[1]      4 : Success(name=tick)
[1]    2 : Running(cursor=2,len=3)
[1]      5 : Running(cursor=0,len=2)
[1]        6 : Success(k=a,i=1)
[1]      5 : Running(cursor=1,len=2)
[1]        7 : Running(cursor=0,len=2)
[1]          8 : Failure(key=x,expected=10,reason=1 != 10)
[1]        7 : Running(cursor=1,len=2)
[1]          9 : Running()
[1]        7 : Running(cursor=1,len=2)
[1]      5 : Running(cursor=1,len=2,prev_cursor=1)
[1]    2 : Running(cursor=2,len=3)
[2]  next tick
[2]    2 : Running(cursor=0,len=3)
[2]      3 : Success(key=x,value=tick)
[2]    2 : Running(cursor=1,len=3)
[2]      4 : Success(name=tick)
[2]    2 : Running(cursor=2,len=3)
[2]      5 : Running(cursor=0,len=2,prev_cursor=1)
[2]        7 : Running(cursor=0,len=2)
[2]          8 : Failure(key=x,expected=10,reason=2 != 10)
[2]        7 : Running(cursor=1,len=2)
[2]          9 : Running()
[2]        7 : Running(cursor=1,len=2)
[2]      5 : Running(cursor=0,len=2,prev_cursor=1)
[2]    2 : Running(cursor=2,len=3)
[2]  1 : Running(cursor=0,len=1)
</code></pre>
<p>The first symbol <code>[X]</code> denotes the current tick.
The indent shows the level of nesting.
Next it is a pairt of node id and the status with parameters.</p>
<h2 id="custom-messages"><a class="header" href="#custom-messages">Custom messages</a></h2>
<p>The users can add the custom messages using the parameter <code>Tracer</code> from context:</p>
<pre><code class="language-f-tree">impl custom_state();
root main repeat(3) custom_state()
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct CT;

    impl Impl for CT {
        fn tick(&amp;self, args: RtArgs, ctx: &amp;mut TreeContext) -&gt; Tick {
            let i = ctx
                .bb()
                .get("k".to_string())?
                .and_then(|v| v.clone().as_int())
                .map(|v| v + 1)
                .unwrap_or_default();

            ctx.bb().put("k".to_string(), RtValue::int(i));
            // the method trace accepts Event::Custom
            ctx.trace(format!("i = {:?}", i));
            
            Ok(TickResult::success())
        }
    }

<span class="boring">}</span></code></pre></pre>
<p>That will give the following trace:</p>
<pre><code>[1]  1 : Running(cursor=0,len=1)
[1]    2 : Running(len=1)
[1]      i = 0
[1]      3 : Success()
[1]    2 : Running(arg=2,cursor=0,len=1)
[2]  next tick
[2]    2 : Running(arg=2,cursor=0,len=1)
[2]      i = 1
[2]      3 : Success()
[2]    2 : Running(arg=3,cursor=0,len=1)
[2]  1 : Running(cursor=0,len=1)
[3]  next tick
[3]    2 : Running(arg=3,cursor=0,len=1)
[3]      i = 2
[3]      3 : Success()
[3]    2 : Success(arg=3,cursor=0,len=1)
[3]  1 : Running(cursor=0,len=1)
[3]  1 : Success(cursor=0,len=1)
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The tracer has a few settings.</p>
<ul>
<li>indent: the indent of the lines depending on the nesting level</li>
<li>to_file: if the file is provided, the trace will be redirected into this file.</li>
<li>time_format: if provided, the current time format.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn file() {
    let mut fb = fb("tracer/custom");
    let tracer_log = test_folder("tracer/custom/main.trace");

    fb.tracer(Tracer::create(TracerConfiguration {
        indent: 2,
        to_file: Some(tracer_log.clone()),
        time_format: None
    }));

    let mut f = fb.build().unwrap();
    let result = f.start();
    assert_eq!(result, Ok(TickResult::success()));

    let file_trace = fs::read_to_string(tracer_log).unwrap();
    assert_eq!(file_trace, f.tracer.to_string())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulation-1"><a class="header" href="#simulation-1">Simulation</a></h1>
<p>Forester provides a conception to execute the given tree, replacing the actions to stubs.
The major intention is to test the tree behavior and test all branches under the specific conditions
without coding the implementations at all.
The profile enables to mix in the specific state of blackboard, trace the changes and visualize the tree.</p>
<h2 id="preparations"><a class="header" href="#preparations">Preparations</a></h2>
<h3 id="configuration-profile"><a class="header" href="#configuration-profile">Configuration profile</a></h3>
<p><strong>All paths in the configuration files can be either absolute or relative to the root folder</strong></p>
<p>The file contains the settings information alongside with the information about stubbed options.</p>
<p>Below, the example of the file:</p>
<pre><code class="language-yaml">config:
  tracer: 
    file: gen/main.trace
    dt_fmt: "%d %H:%M:%S%.3f"
  graph: gen/main.svg
  bb:
    dump: gen/bb.json
  max_ticks: 10

actions:
  -
    name: task
    stub: failure
    params:
      delay: 100
</code></pre>
<p>Config section:</p>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th><th>Example</th></tr></thead><tbody>
<tr><td>tracer.file</td><td>the tracer settings to write to a file</td><td>if it is absent, there will be no action</td><td>gen/main.trace</td></tr>
<tr><td>tracer.dt_fmt</td><td>the tracer settings to given data format</td><td>if it is absent, there will be no action</td><td>"%d %H:%M:%S%.3f"</td></tr>
<tr><td>graph</td><td>the visualization file</td><td>if it is absent, there will be no action</td><td>gen/main.svg</td></tr>
<tr><td>bb.dump</td><td>the dump of the bb at the end</td><td>if it is absent, there will be no action</td><td>gen/bb.json</td></tr>
<tr><td>bb.load</td><td>the dump that will be used to init bb before sim</td><td>if it is absent, there will be no action</td><td>gen/init_bb.json</td></tr>
<tr><td>max_ticks</td><td>the maximum amount of ticks to work.</td><td>0 by default</td><td>10</td></tr>
<tr><td>http.port</td><td>The port for http server to communicate with the remote actions .</td><td>if it is absent, there will be no action</td><td>8080</td></tr>
</tbody></table>
</div>
<p>Actions sections:</p>
<p>The actions sections is an array to stub the actions</p>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th><th>Example</th></tr></thead><tbody>
<tr><td>name</td><td>the name of the stubbed action</td><td>should be presented</td><td>name</td></tr>
<tr><td>stub</td><td>the stubbed implementation</td><td>should be presented</td><td>success</td></tr>
<tr><td>params.delay</td><td>denotes the pause before start in millis</td><td>0</td><td>100</td></tr>
<tr><td>params.url</td><td>(For remote stub) the url to connect</td><td>should be presented</td><td>http://localhost:10000/action</td></tr>
<tr><td>params.server</td><td>(For remote stub) the url to provide to action to connect to bb</td><td>http://localhost</td><td>http://localhost:8080</td></tr>
</tbody></table>
</div>
<h4 id="default-profile"><a class="header" href="#default-profile">Default profile</a></h4>
<p>The simulation can be performed without giving the specific profile.
In that case, all actions that need to implement will be replaced with the success stub.
Other artifacts will not be generated.</p>
<h3 id="stubs"><a class="header" href="#stubs">Stubs</a></h3>
<ul>
<li>success: returns a success</li>
<li>failure: returns a failure</li>
<li>random: returns either a failure or a success randomly</li>
<li>remote: connects to the remote server and returns the result of the action. The details can be found in the <a href="./r_actions.html#remote-actions">Remote action</a>.</li>
</ul>
<p>The stubs success, failure, random have the following param:</p>
<ul>
<li>delay: in millis, the time to delay the stub.</li>
</ul>
<p>The remote stub has the following params:</p>
<ul>
<li>url: the url to connect to the remote server</li>
<li>server: the url to provide to the remote server to connect to the blackboard</li>
</ul>
<h2 id="process"><a class="header" href="#process">Process</a></h2>
<p>The simulation can be performed in on of two ways:</p>
<ul>
<li>using console application from console</li>
<li>using a library from rust code</li>
</ul>
<h3 id="in-the-code"><a class="header" href="#in-the-code">In the code</a></h3>
<p>Just use the builder and the simulator from the <code>simulator</code> module. For details,
please see the doc for <code>ForesterBuilder</code> and <code>SimulatorBuilder</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn smoke() {
     let mut sb = SimulatorBuilder::new();

     let root = PathBuf::from("simulator/smoke");

     sb.root(root.clone());
     sb.profile(PathBuf::from("sim.yaml"));
     
     let mut fb = ForesterBuilder::from_file_system();

     fb.main_file("main.tree".to_string());
     fb.root(root);

     sb.forester_builder(fb);
     
     let mut sim = sb.build().unwrap();
     sim.run().unwrap();
 }

 fn smoke_from_text() {
     let mut sb = SimulatorBuilder::new();

     let sim = PathBuf::from("simulator/smoke/sim.yaml");
     let mut fb = ForesterBuilder::from_text();
     sb.profile(sim);
     
     fb.text(
         r#"
 import "std::actions"

 root main sequence {
     store("info1", "initial")
     retryer(task(config = obj), success())
     store("info2","finish")
 }

 fallback retryer(t:tree, default:tree){
     retry(5) t(..)
     fail("just should fail")
     default(..)
 }

 impl task(config: object);
     "#
         .to_string(),
     );    
     sb.forester_builder(fb);
     let mut sim = sb.build().unwrap();
     sim.run().unwrap();
 }

<span class="boring">}</span></code></pre></pre>
<h3 id="in-the-console"><a class="header" href="#in-the-console">In the console</a></h3>
<p>Just use a <code>f-tree</code> console cli to run a simulation</p>
<pre><code class="language-shell">f-tree sim --root tree\tests\simulator\smoke\  --profile sim.yaml
</code></pre>
<ul>
<li>root can be omitted, the <code>&lt;pwd&gt;</code> folder will be taken by default</li>
<li>tree can be omitted if only one root definition in the file</li>
<li>main can be omitted, by default, the name <code>main.tree</code> will be taken.</li>
<li>profile can be omitted, the default profile will be taken.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="export-to-ros-nav2"><a class="header" href="#export-to-ros-nav2">Export to ROS Nav2</a></h1>
<p><a href="https://www.ros.org/">ROS</a> in general and <a href="https://navigation.ros.org/">ROS Nav2</a> in particular are very popular in robotics.
They take care of many aspects of robot control, including navigation, localization, mapping, and more.</p>
<p>Forester provides a way to export a tree to ROS Nav2.
The intermediate format is <a href="https://navigation.ros.org/behavior_trees/index.html#">Nav2</a> XML format.</p>
<p>The transformation format for now is pretty straightforward.</p>
<h2 id="control-nodes"><a class="header" href="#control-nodes">Control nodes</a></h2>
<p>The control nodes are mapped to the nav2 control nodes directly:</p>
<ul>
<li><code>PipelineSequence</code> to <code>sequence</code></li>
<li><code>RoundRobin</code> to <code>fallback</code></li>
<li><code>ReactiveFallback</code> to <code>r_fallback</code></li>
</ul>
<p>If the control node has a name, it is used as the name of the control node in the nav2 tree.</p>
<pre><code>sequence FollowPathWithFallback{
    .. 
}
</code></pre>
<p>will become</p>
<pre><code class="language-xml">&lt;PipelineSequence name="FollowPathWithFallback"&gt;
&lt;/PipelineSequence&gt;
</code></pre>
<h2 id="actions-2"><a class="header" href="#actions-2">Actions</a></h2>
<p>The actions can be mapped straightforwardly to the nav2 actions.</p>
<p>Every action can implicitly take a <code>name</code> parameter, which is used as the name of the action in the nav2 tree.
But the name parameter can be omitted also.</p>
<p>Some of the actions take the subtree as a parameter. The parameter has a name <code>sub</code></p>
<h3 id="retry-1"><a class="header" href="#retry-1">Retry</a></h3>
<p>Retry is represented in two options:</p>
<ul>
<li><code>Retry</code> - the number of retries is specified  without a name like <code>retry(3)</code></li>
<li><code>RecoveryNode</code> - the number of retries is specified with the default way like <code>RecoveryNode(number_of_retries = 3)</code>.
This becomes only way to convey the name of the node.</li>
</ul>
<pre><code class="language-f-tree">    RecoveryNode(
            number_of_retries = 1,
            name = "ComputePathToPose", // it allows to convey the name
            sub = ComputePathWithFallback()
        )
    retry(1) ComputePathWithFallback() // it is not possible to convey the name
    
    // but everything else is the same    
</code></pre>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-f-tree">import "ros::nav2"

root MainTree RecoveryNode(number_of_retries = 6, name = "NavigateRecovery", sub = NavigateWithReplanning())

sequence NavigateWithReplanning {
    RateController(
        hz = 1.0,
        sub = RecoveryNode(
            number_of_retries = 1,
            name = "ComputePathToPose",
            sub = retry(1) ComputePathWithFallback()
        )
    )
    retry(1) FollowPathWithFallback()
}
sequence ComputePathWithFallback{
    ComputePathToPose(goal = goal,path = path,planner_id = "GridBased")
    ComputePathToPoseRecoveryFallback()
}

sequence FollowPathWithFallback{
    FollowPath(path = path,controller_id = "FollowPath")
    FollowPathRecoveryFallback()
}

r_fallback ComputePathToPoseRecoveryFallback {
    GoalUpdated()
    ClearEntireCostmap(name = "ClearGlobalCostmap-Context", service_name = "global_costmap/clear_entirely_global_costmap")
}
r_fallback FollowPathRecoveryFallback {
    GoalUpdated()
    ClearEntireCostmap(name = "ClearLocalCostmap-Context", service_name = "local_costmap/clear_entirely_local_costmap")
}
</code></pre>
<p>will be transformed into</p>
<pre><code class="language-xml">&lt;root main_tree_to_execute="MainTree"&gt;
  &lt;BehaviorTree ID="MainTree"&gt;
    &lt;RecoveryNode number_of_retries="6" name="NavigateRecovery"&gt;
      &lt;PipelineSequence name="NavigateWithReplanning"&gt;
        &lt;RateController hz="1"&gt;
          &lt;RecoveryNode number_of_retries="1" name="ComputePathToPose"&gt;
            &lt;RecoveryNode number_of_retries="1"&gt;
              &lt;PipelineSequence name="ComputePathWithFallback"&gt;
                &lt;ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/&gt;
                &lt;ReactiveFallback name="ComputePathToPoseRecoveryFallback"&gt;
                  &lt;GoalUpdated/&gt;
                  &lt;ClearEntireCostmap name="ClearGlobalCostmap-Context" service_name="global_costmap/clear_entirely_global_costmap"/&gt;
                &lt;/ReactiveFallback&gt;
              &lt;/PipelineSequence&gt;
            &lt;/RecoveryNode&gt;
          &lt;/RecoveryNode&gt;
        &lt;/RateController&gt;
        &lt;RecoveryNode number_of_retries="1"&gt;
          &lt;PipelineSequence name="FollowPathWithFallback"&gt;
            &lt;FollowPath path="{path}" controller_id="FollowPath"/&gt;
            &lt;ReactiveFallback name="FollowPathRecoveryFallback"&gt;
              &lt;GoalUpdated/&gt;
              &lt;ClearEntireCostmap name="ClearLocalCostmap-Context" service_name="local_costmap/clear_entirely_local_costmap"/&gt;
            &lt;/ReactiveFallback&gt;
          &lt;/PipelineSequence&gt;
        &lt;/RecoveryNode&gt;
      &lt;/PipelineSequence&gt;
    &lt;/RecoveryNode&gt;
  &lt;/BehaviorTree&gt;
&lt;/root&gt;
</code></pre>
<h2 id="tools-1"><a class="header" href="#tools-1">Tools</a></h2>
<p>The changes arrived in the latest version of f-tree, therefore better to update f-tree</p>
<pre><code class="language-shell">cargo install f-tree 
</code></pre>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>To have headers for nav2 actions, you need to import the <code>ros::nav2</code> module in your project.
To see the content of the file, run</p>
<pre><code class="language-shell">f-tree -d print-ros-nav2
</code></pre>
<h3 id="export-from-console"><a class="header" href="#export-from-console">Export from console</a></h3>
<p>To export the tree from the console, run</p>
<pre><code class="language-shell">f-tree.exe nav2 
</code></pre>
<h3 id="export-from-intellij-plugin"><a class="header" href="#export-from-intellij-plugin">Export from Intellij plugin</a></h3>
<p>Run the task <code>Export to ROS Nav2</code></p>
<h3 id="export-from-code"><a class="header" href="#export-from-code">Export from code</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn smoke() {
    let mut root_path = test_folder("ros/nav/smoke");

    let project = Project::build("main.tree".to_string(), root_path.clone()).unwrap();
    let tree = RuntimeTree::build(project).unwrap().tree;
    fb.push("test.xml");
    
    tree.to_ros_nav(root_path.clone()).unwrap();

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="tools-2"><a class="header" href="#tools-2">Tools</a></h1>
<p>Tools include the auxiliary libraries to help to process the trees:</p>
<h2 id="intellij-plugin"><a class="header" href="#intellij-plugin">Intellij plugin</a></h2>
<p>The plugin provides the following features:</p>
<ul>
<li>Syntax highlighting</li>
<li>Code folding</li>
<li>Code navigation</li>
<li>Code formatting</li>
<li>Code inspection</li>
<li>Structure view</li>
<li>Task to visualize and simulate the given tree</li>
</ul>
<h2 id="remote-action-libraries"><a class="header" href="#remote-action-libraries">Remote Action Libraries</a></h2>
<p>The libraries provide the following features:</p>
<ul>
<li>The ability to run the tree on the remote machine and get the result back</li>
<li>To get access to blackboard from the remote machine</li>
</ul>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intellij-plugin-1"><a class="header" href="#intellij-plugin-1">Intellij plugin</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This plugin enriches your development experience by providing seamless task orchestration capabilities,
allowing you to perform tasks synchronously or asynchronously,
locally or remotely, all within the familiar IntelliJ environment.
Whether you are working on game development, artificial intelligence, robotics, or any domain requiring efficient task management,
the Forester-IntelliJ Plugin is here to simplify your workflow and boost productivity.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>To install the Forester-IntelliJ Plugin, follow these simple steps:</p>
<ol>
<li>Open your IntelliJ IDE.</li>
<li>Go to "Settings" or "Preferences" from the main menu.</li>
<li>Choose "Plugins" from the left-hand side menu.</li>
<li>Click on the "Marketplace" or "Browse repositories" button.</li>
<li>Search for "Forester-IntelliJ Plugin."</li>
<li>Click "Install" and restart the IDE to activate the plugin.</li>
</ol>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h3>
<p>The Forester-IntelliJ Plugin includes specialized syntax highlighting, making it easier for you to identify and distinguish Forester-related elements in your code.
This feature helps improve code readability and ensures that your tasks are accurately represented.</p>
<h3 id="folding"><a class="header" href="#folding">Folding</a></h3>
<p>With the folding feature, you can conveniently collapse sections of your behavior trees, making complex task structures more manageable.
Folding enhances code organization and enables you to focus on specific parts of the task tree as needed.</p>
<h3 id="structure-view"><a class="header" href="#structure-view">Structure View</a></h3>
<p>The plugin provides an intuitive Structure View that displays the hierarchical organization of your behavior trees.
Quickly navigate through the task structure, identify parent-child relationships, and easily access specific sections of your tasks with ease.</p>
<h3 id="task-visualization"><a class="header" href="#task-visualization">Task Visualization</a></h3>
<p>The Forester-IntelliJ Plugin offers a task to visualize the tree that brings behavior trees to life.
Gain valuable insights into your task flows and dependencies through interactive graphical representations.
This visual aid fosters a better understanding of your task hierarchy, facilitating effective task organization and management.</p>
<h3 id="task-simulation"><a class="header" href="#task-simulation">Task Simulation</a></h3>
<p>With the task simulation feature, you can run and test your behavior trees directly within the IntelliJ IDE.
Simulate task executions to verify their correctness and efficiency, enabling you to fine-tune your task orchestration process.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="creating-a-new-task"><a class="header" href="#creating-a-new-task">Creating a New Task</a></h3>
<ol>
<li>Navigate to the "Edit configurations" menu in your IntelliJ IDE.</li>
<li>Select "New Task" to create a new task.</li>
</ol>
<h3 id="running-simulation-and-visualization-task"><a class="header" href="#running-simulation-and-visualization-task">Running Simulation and Visualization Task</a></h3>
<ol>
<li>Open the behavior tree you want to simulate.</li>
<li>Click on the "Run Simulation" button to initiate the simulation process (on the gutter on the root tree)</li>
<li>Observe the execution flow and identify any potential issues or optimizations.</li>
</ol>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/besok/forester-intellij-plugin">repo</a></li>
<li><a href="">plugin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-to-create-remote-actions-using-rust"><a class="header" href="#library-to-create-remote-actions-using-rust">Library to create Remote Actions using Rust</a></h1>
<p>The Forester provides a http library that alleviates writing the remote http actions.
For now, the libraries are available for Rust and Python.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-to-create-remote-actions-using-rust-1"><a class="header" href="#library-to-create-remote-actions-using-rust-1">Library to create Remote Actions using Rust</a></h1>
<p>The Forester provides an http library that alleviates writing the remote http actions.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-toml">forester-http = { version = "0.1.0" }
</code></pre>
<p>The contract is defined in the following way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ForesterRemoteAction {
    fn tick(&amp;self, request: RemoteActionRequest) -&gt; TickResult;
}
<span class="boring">}</span></code></pre></pre>
<p>where RemoteActionRequest is defined as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RemoteActionRequest {
    /// current tick
    pub tick: usize,
    /// the list of arguments from the tree invocation
    pub args: Vec&lt;RtArgument&gt;,
    /// the address of the server to access to blackboard and other services
    pub serv_url: String,
}
<span class="boring">}</span></code></pre></pre>
<p>On the other hand, the library provides a helper API <code>ForesterHttpApi</code> and Client <code>ForesterHttpClient</code> (async reqwest) to access the server.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>The code is available in the <a href="https://github.com/besok/forester-examples/tree/main/remote_action/simple_action">forester-examples</a> repository.</p>
<p>The gist is the following:</p>
<pre><pre class="playground"><code class="language-rust">
#[tokio::main]
async fn main() {
    let routing = Router::new()
        .route("/", get(|| async { "OK" }))
        .route("/action", post(handler))
        .into_make_service_with_connect_info::&lt;SocketAddr&gt;();

    axum::Server::bind(&amp;SocketAddr::from(([127, 0, 0, 1], 10000)))
        .serve(routing)
        .await
        .unwrap();
}


/// RemoteActionRequest defines the request from the tree
async fn handler(Json(req): Json&lt;RemoteActionRequest&gt;) -&gt; impl IntoResponse {
    let url = req.clone().serv_url;
    /// the client to access the server
    let client = ForesterHttpClient::new(url);
    let trace = client .print_trace(); /// print the trace of the tree

    let result = client.put("test".to_string(), json!({"f1":1, "f2":2, "f3":3})).await;
    println!("result of putting {:?}", result);
    
    client.lock("test".to_string()).await.unwrap();

    (StatusCode::OK, Json::from(RemoteAction.tick(req)))
}

struct RemoteAction;

impl ForesterRemoteAction for RemoteAction {
    fn tick(&amp;self, request: RemoteActionRequest) -&gt; TickResult {
        println!("tick: {:?}", request);
        TickResult::Success
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-to-create-remote-actions-using-python"><a class="header" href="#library-to-create-remote-actions-using-python">Library to create Remote Actions using Python</a></h1>
<p>The Forester provides an http library that alleviates writing the remote http actions.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>The latest version can be obtained from the <a href="https://test.pypi.org/project/forester-http/">test.pypi.org</a></p>
<pre><code class="language-shell">pip install -i https://test.pypi.org/simple/ forester-http==0.0.5
</code></pre>
<p>The contract is defined in the following way:</p>
<pre><code class="language-python">from typing import List

class RtArgument:
    """The argument that is sent from the Forester instance

    * The name of the argument
    * The value of the argument is a json
    """

    def __init__(self, name: str, value: str) -&gt; None:
        self.name = name
        self.value = value


class RemoteActionRequest:
    """The request that is sent from the Forester instance

    * It has the current tick and the arguments in the action from tree
    """

    def __init__(self, tick: int, args: List[RtArgument], serv_url: str) -&gt; None:
        self.tick = tick
        self.args = args
        self.serv_url = serv_url


</code></pre>
<p>On the other hand, the library provides a helper API <code>ForesterHttpApi</code> and Client <code>ForesterHttpClient</code>  to access the server.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>The code is available in the <a href="https://github.com/besok/forester-examples/tree/main/remote_action/simple_action_py">forester-examples</a> repository.</p>
<p>The gist is the following:</p>
<pre><code class="language-python">
import json
from http.server import BaseHTTPRequestHandler, HTTPServer

from forester_http.client import *

class MyServer(BaseHTTPRequestHandler):
    def do_POST(self):
    
        if self.path == "/action":
            content_length = int(self.headers["Content-Length"])
            # get body as json and deserialize it to RemoteActionRequest
            body = json.loads(self.rfile.read(content_length))
            req = RemoteActionRequest.from_bytes(body.encode("utf-8"))
    
            client = ForesterHttpClient(req.serv_url)
            client.put("test", "test")
    
            self.send_response(200)
            self.send_header("Content-Type", "application/json;charset=UTF-8")
            self.end_headers()
    
            self.wfile.write(json.dumps("Success").encode("utf-8"))
    
        else:
            self.send_error(404)


if __name__ == "__main__":
    webServer = HTTPServer((hostName, serverPort), MyServer)
    print("Server started http://%s:%s" % (hostName, serverPort))

    try:
        webServer.serve_forever()
    except KeyboardInterrupt:
        pass

    webServer.server_close()
    print("Server stopped.")

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="console-f-tree"><a class="header" href="#console-f-tree">Console f-tree</a></h1>
<p>The console utility <code>f-tree</code> can be installed using <code>cargo</code> and can be used to simulate and visualize the tree.</p>
<p>The <a href="intellij.html">Intellij plugin</a> basically wraps this utility and provides the same functionality.</p>
<pre><code class="language-shell">cargo install f-tree
</code></pre>
<p>and then be used with</p>
<pre><code class="language-shell">~ f-tree --help
Usage: f-tree [OPTIONS] &lt;COMMAND&gt;

Commands:
  print-std-actions  Print the list of std actions from 'import std::actions'
  print-ros-nav2     Print the list of ros actions from 'import ros::nav2'
  sim                Runs simulation. Expects a simulation profile
  vis                Runs visualization. Output is in svg format.
  nav2               Convert to the xml compatable format of nav ros2.
  help               Print this message or the help of the given subcommand(s)

Options:
  -d, --debug    Print debug logs
  -h, --help     Print help
  -V, --version  Print version


</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid-init.js"></script>
        <script src="mermaid.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
